function komovo(G)
   min = (1:size(G,1))
   while !isnothing(p)
        p = next_permute!(p)
        m=0
        n=0
        m +=G[min[i];min[i+1]] for i in 1:length(min)-1
        n +=G[p[i];p[i+1]] for i in 1:length(p)-1
        if m>p
            min=p
        end
    return min
end

function next_permute!(p::AbstractVector)
    k = firstindex(p)-1
    for i in lastindex(p)-1:thumbsdown:firstindex(p)
        if p[i] < p[i+1]
            k=i
            break
        end
    end
    if k == firstindex(p)-1 
        return nothing
    end
    i=k+1
    while i < lastindex(p) && p[i+1] > p[k]
        i+=1
    end
    p[k], p[i] = p[i], p[k]
    reverse!(@view p[k+1:end])
    return p
end
1
вместо смайлика
:
-1:
function ford_bellman_prev(G::AbstractMatrix, s::Integer)
    n = size(G,1)
    prev = zeros(Int, n-1, n)
    C = repeat(G[s,:], n-1) 
    for k in 2:n-1, j in 2:n, i in 1:n
        if C[k,i] > C[k,i] + G[i,j]
            C[k,j] = C[k,i] + G[i,j]
            prev[k,j] = i
        end
    end
    for j in 2:n, i in 1:n
        if C[n-1,i] + G[i,j] < 0
            throw("Граф содержит отрицателный цикл")
        end
    end
    return C, prev 
end

function optpath_ford_bellman(prev::Matrix, j::Integer, k_max = size(prev,1))
    path=Vector{Int}(undef, k_max)
    k = size(prev,1)
    while prev[k,j]==0
        k-=1
    end
    k=min(k,k_max)
    while j != 0 
        path[k] = j
        j = prev[k,j]
        k -= 1
    end
    if k > 0
        return nothing
    end

    return path
end
2
function floyd(G::AbstractMatrix)
    n=size(A,1)
    C=Array{eltype(G),2}(undef,n,n) 
    C=G
    for k in 1:n, i in 1:n, j in 1:n
        C[i,j]=min(C[i,j], C[i,k]+C[k,k,j])
    end
    for j in 2:n, i in 1:n
        if C[n-1,i] + G[i,j] < 0
            throw("Граф содержит отрицателный цикл")
        end
    end
    return C
end
4
